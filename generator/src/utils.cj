package imgui4cj_generator

import std.collection.{HashSet, any, map}
import std.collection.{ArrayList, HashMap, TreeMap, forEach, enumerate}
import std.io.{OutputStream, StringWriter}
import std.fs.{File, OpenOption}
import std.ast
import std.convert.*
import encoding.json.*

const AUTOGENERATED_FILE_HEAD_COMMENTS = """
// +------------------------------------------------------+
// + THIS FILE IS AUTO-GENERATED BY `imgui4cj_generator`. +
// +       FROM: https://github.com/PGZXB/imgui4cj        +
// +-------------------- DO NOT EDIT. --------------------+"""
const CAPI_IMPL_SYMBOL_PREFIX = "_capi_"

extend<T> ArrayList<T> {
    static func fromIterator(iter: Iterable<T>): ArrayList<T> {
        let result = ArrayList<T>()
        iter |> forEach {
            val => result.append(val)
        }
        return result
    }
}

extend<K, V> HashMap<K, V> {
    func getOrPut(key: K, putVL: () -> V): V {
        if (!this.contains(key)) {
            this[key] = putVL()
        }
        return this[key]
    }
}

func withIndex<T>(it: Iterable<T>): Iterator<(Int64, T)> {
    return enumerate<T>(it)
}

func readJsonFile(path: String): JsonValue {
    return JsonValue.fromStr(String.fromUtf8(File.openRead(path).readToEnd()))
}

func getPkgName(path: String): String {
    return path[(path.lastIndexOf(".").getOrThrow {
            IllegalArgumentException("illegal argument path: `${path}`")
        } + 1)..]
}

let CJ_BASIC_TYPE_OF_C_TYPE = HashMap<String, CjType>(
    [
        ("void", UnitType),
        ("bool", BoolType),
        ("signed char", Int8Type),
        ("char", UInt8Type),
        ("unsigned char", UInt8Type),
        ("int8_t", Int8Type),
        ("uint8_t", UInt8Type),
        ("signed short", Int16Type),
        ("short", Int16Type),
        ("int16_t", Int16Type),
        ("unsigned short", UInt16Type),
        ("uint16_t", UInt16Type),
        ("signed int", Int32Type),
        ("int", Int32Type),
        ("int32_t", Int32Type),
        ("unsigned int", UInt32Type),
        ("uint32_t", UInt32Type),
        ("signed long long", Int64Type),
        ("int64_t", Int64Type),
        ("unsigned long long", UInt64Type),
        ("uint64_t", UInt64Type),
        ("ssize_t", IntNativeType),
        ("size_t", UIntNativeType),
        ("float", Float32Type),
        ("double", Float64Type),
        ("char*", CStringType),
        ("FILE", UnitType) // FILE* -> CPointer<Unit>
    ]
)

enum CjTemplateType <: ToString {
    | CPointerType

    public func toString(): String {
        return match (this) {
            case CPointerType => "CPointer"
        }
    }
}

// NOTE: Only for this project, not complete
enum CjType <: ToString {
    | UnitType
    | BoolType
    | Int8Type
    | UInt8Type
    | Int16Type
    | UInt16Type
    | Int32Type
    | UInt32Type
    | Int64Type
    | UInt64Type
    | IntNativeType
    | UIntNativeType
    | Float32Type
    | Float64Type
    | CStringType
    | CFuncType(Array<(String, CjType)>, CjType) // param-types, ret-type
    | VArrayType(CjType, Int64)
    | StructType(String)
    | TypeAlias(String) // type a = b
    | TemplateType(CjTemplateType, Array<CjType>)

    func getPointer(): CjType {
        return TemplateType(CPointerType, [this])
    }

    func getVArray(size: Int64): CjType {
        return VArrayType(this, size)
    }

    public func toString(): String {
        return match (this) {
            case UnitType => "Unit"
            case BoolType => "Bool"
            case Int8Type => "Int8"
            case UInt8Type => "UInt8"
            case Int16Type => "Int16"
            case UInt16Type => "UInt16"
            case Int32Type => "Int32"
            case UInt32Type => "UInt32"
            case Int64Type => "Int64"
            case UInt64Type => "UInt64"
            case IntNativeType => "IntNative"
            case UIntNativeType => "UIntNative"
            case Float32Type => "Float32"
            case Float64Type => "Float64"
            case CStringType => "CPointer<UInt8>"
            case CFuncType(pTypes, retType) =>
                // CFunc<(argName: CPointer<Int8>) -> Unit>
                let sb = StringBuilder()
                sb.append("CFunc<(")
                for ((i, (n, t)) in withIndex(pTypes)) {
                    sb.append("${n}: ${t}")
                    if (i != pTypes.size - 1) {
                        sb.append(", ")
                    }
                }
                sb.append(") -> ${retType}")
                sb.append(">")
                sb.toString()
            case VArrayType(ty, size) => "VArray<${ty}, \$${size}>"
            case StructType(name) => name
            case TypeAlias(name) => name
            case TemplateType(ty, tyArgs) =>
                // CPointer<T>
                let sb = StringBuilder()
                sb.append("${ty}<")
                for ((i, t) in withIndex(tyArgs)) {
                    sb.append(t)
                    if (i != tyArgs.size - 1) {
                        sb.append(", ")
                    }
                }
                sb.append(">")
                sb.toString()
        }
    }

    func getDefaultValueLiteral(typeAlias!: ?HashMap<String, CjType> = None): String {
        return match (this) {
            case BoolType => "false"
            case Int8Type => "0"
            case UInt8Type => "0"
            case Int16Type => "0"
            case UInt16Type => "0"
            case Int32Type => "0"
            case UInt32Type => "0"
            case Int64Type => "0"
            case UInt64Type => "0"
            case IntNativeType => "0"
            case UIntNativeType => "0"
            case Float32Type => "0.0f32"
            case Float64Type => "0.0f64"
            case CStringType => "CPointer<UInt8>()"
            case CFuncType(pTypes, retType) => "${this}(CPointer<Unit>())"
            case VArrayType(ty, size) => "${this}(item: ${ty.getDefaultValueLiteral(typeAlias: typeAlias)})"
            case StructType(name) => "${this}()"
            case TypeAlias(name) => if (let Some(td) <- typeAlias) {
                td.get(name)?.getDefaultValueLiteral(typeAlias: typeAlias) ?? "${this}()"
            } else {
                "${this}()"
            }
            case TemplateType(ty, tyArgs) => "${this}()"
            case _ => throw UnsupportedException("${this} do not have default value literal")
        }
    }

    static func fromCType(ty: String, size!: ?Int64 = None, cArrayAsPointer!: Bool = false): CjType {
        return getCjTypeOfCType(ty, size: size, cArrayAsPointer: cArrayAsPointer)
    }

    private static func tryGetCjTypeOfBuiltinCType(ty: String): ?CjType {
        return CJ_BASIC_TYPE_OF_C_TYPE.get(ty) ?? CJ_BASIC_TYPE_OF_C_TYPE.get(ty)
    }

    private static func tryGetCjTypeOfCArrayType(ty: String, cArrayAsPointer: Bool): ?CjType {
        if (!ty.endsWith("]") || ty.count("]") != 1 || ty.count("[") != 1) {
            return None
        }

        let leftPPos = ty.indexOf("[").getOrThrow()
        let size = ty[leftPPos + 1..].trimRight("]")
        let cjTy = fromCType(ty[0..leftPPos])
        return if (size.isEmpty() || cArrayAsPointer) {
            cjTy.getPointer()
        } else {
            cjTy.getVArray(Int64.parse(size))
        }
    }

    private static func tryGetCjTypeOfCPointer(ty: String, cArrayAsPointer!: Bool = false): ?CjType {
        if (!ty.endsWith("*")) {
            return None
        }

        let baseTy = ty[0..ty.size - 1].trimLeft("const").trimAscii()
        let baseCjTy = getCjTypeOfCType(baseTy, cArrayAsPointer: cArrayAsPointer)
        return baseCjTy.getPointer()
    }

    private static func tryGetCjTypeOfCExplicitStructType(ty: String): ?CjType {
        if (!ty.startsWith("struct ")) {
            return None
        }
        return StructType(ty.trimLeft("struct "))
    }

    private static func tryGetCjTypeOfCFunc(ty: String): ?CjType {
        // void(*)(const ImDrawList* parent_list,const ImDrawCmd* cmd);
        if (!ty.contains("(*)(")) {
            return None
        }

        if (ty.count("(*)(") != 1) {
            throw UnsupportedException("Only one '(*)(\"' is allowed")
        }

        let retAndParams = ty.trimRight(";").trimRight(")").split("(*)(")
        let retCType = retAndParams[0].trimAscii()
        let paramCTypes = retAndParams[1].split(",")

        return CFuncType(
            Array<(String, CjType)>(paramCTypes.size) {
                i =>
                let lastSpacePos = paramCTypes[i].lastIndexOf(" ").getOrThrow()
                return (paramCTypes[i][lastSpacePos + 1..].trimAscii(), CjType.fromCType(
                        paramCTypes[i][..lastSpacePos].trimAscii()))
            },
            CjType.fromCType(retCType)
        )
    }

    private static func getCjTypeOfCType(_ty: String, size!: ?Int64 = None, cArrayAsPointer!: Bool = false): CjType {
        let ty = _ty.replace("const ", "").trimAscii().replace(" const", "").trimAscii()
        let cjTy = tryGetCjTypeOfBuiltinCType(ty) ?? tryGetCjTypeOfCArrayType(ty, cArrayAsPointer) ??
            tryGetCjTypeOfCPointer(ty, cArrayAsPointer: cArrayAsPointer) ?? tryGetCjTypeOfCFunc(ty) ??
            tryGetCjTypeOfCExplicitStructType(ty) ?? TypeAlias(ty)

        return match (size) {
            case Some(size) => if (cArrayAsPointer) {
                cjTy.getPointer()
            } else {
                cjTy.getVArray(size)
            }
            case None => cjTy
        }
    }
}

func getCjStructMemberName(mdef: StructMemberDef): String {
    if (let Some(_) <- mdef.size) {
        return mdef.name[0..mdef.name.indexOf("[").getOrThrow()]
    }

    return mdef.name
}

func evalIntConstExprImpl(e: ast.Expr, t: ?HashMap<String, String>): Int64 {
    // simple but enough
    return match (e) {
        case binExpr: ast.BinaryExpr =>
            let left = evalIntConstExprImpl(binExpr.leftExpr, t)
            let right = evalIntConstExprImpl(binExpr.rightExpr, t)
            match (binExpr.op.kind) {
                case ast.TokenKind.ADD => left + right
                case ast.TokenKind.SUB => left - right
                case ast.TokenKind.MUL => left * right
                case ast.TokenKind.DIV => left / right
                case ast.TokenKind.LSHIFT => left << right
                case ast.TokenKind.RSHIFT => left >> right
                case _ => throw UnsupportedException("Unsupported op `${binExpr.op.value}`")
            }
        case uExpr: ast.UnaryExpr =>
            let val = evalIntConstExprImpl(uExpr.expr, t)
            match (uExpr.op.kind) {
                case ast.TokenKind.SUB => -val
                case _ => throw UnsupportedException("Unsupported op `${uExpr.op.value}`")
            }
        case litExpr: ast.LitConstExpr => Int64.parse(litExpr.literal.value)
        case refExpr: ast.RefExpr =>
            let constantTable = t.getOrThrow {IllegalArgumentException("constants table are not provided but required")}
            let consantValue = constantTable.get(refExpr.identifier.value).getOrThrow {
                IllegalArgumentException("`${refExpr.identifier.value}` are not found")
            }
            Int64.parse(consantValue)
        case parenExpr: ast.ParenExpr => evalIntConstExprImpl(parenExpr.parenthesizedExpr, t)
        case _ => throw UnsupportedException("Unsupported `${e.toTokens()}` expression")
    }
}

func evalIntConstExpr(e: String, constantTable!: ?HashMap<String, String> = None) {
    let tokens = ast.cangjieLex(e)
    let expr = ast.parseExpr(tokens)
    return evalIntConstExprImpl(expr, constantTable)
}

func tryConvertTemplateTypename(ty: String): ?String {
    let leftCnt = ty.count("<")
    let rightCnt = ty.count("<")

    if (leftCnt == 0 || rightCnt == 0) {
        return Option<String>.None
    }

    if (leftCnt != 1 || rightCnt != 1) {
        throw UnsupportedException("Only support `Type<T, N>`-like template types")
    }

    let converted = StringBuilder()
    for (r in ty.trimRight(">").runes()) {
        if (r == r'<') {
            converted.append('_')
        } else if (r == r'>') {
            throw IllegalStateException()
        } else if (r == r'_' || r.isAsciiNumberOrLetter()) {
            converted.append(r)
        } else if (r == r'-') {
            converted.append("less")
        } else if (r == r'*') {
            converted.append("Ptr")
        } else if (r == r',') {
            converted.append("__")
        } else {
            converted.append('_')
        }
    }
    return converted.toString()
}

let CJ_KEYWORKS_TABLE = HashSet<String>(
    [
        "as",
        "abstract",
        "break",
        "Bool",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "Char",
        "do",
        "else",
        "enum",
        "extend",
        "for",
        "from",
        "func",
        "false",
        "finally",
        "foreign",
        "Float16",
        "Float32",
        "Float64",
        "if",
        "in",
        "is",
        "init",
        "import",
        "interface",
        "Int8",
        "Int16",
        "Int32",
        "Int64",
        "IntNative",
        "let",
        "mut",
        "main",
        "macro",
        "match",
        "Nothing",
        "open",
        "operator",
        "override",
        "prop",
        "public",
        "package",
        "private",
        "protected",
        "quote",
        "redef",
        "return",
        "spawn",
        "super",
        "static",
        "struct",
        "synchronized",
        "try",
        "this",
        "true",
        "type",
        "throw",
        "This",
        "unsafe",
        "Unit",
        "UInt8",
        "UInt16",
        "UInt32",
        "UInt64",
        "UIntNative",
        "var",
        "VArray",
        "where",
        "while"
    ]
)

func getValidCjIdentifier(id: String): String {
    // simple but enough

    if (id.startsWith("`") && id.endsWith("`")) {
        return id
    }

    if (id.runes() |> any {
        e: Rune => !e.isAsciiNumberOrLetter() && e != r'_'
    }) {
        throw UnsupportedException("unsupported id to be converted: ${id}")
    }

    return if (CJ_KEYWORKS_TABLE.contains(id)) {
        "`${id}`"
    } else {
        id
    }
}

func getWCAPIArgument(ty: CjType, argName_: String, typeAlias: HashMap<String, CjType>): (String, String) {
    let argName = getValidCjIdentifier(argName_)
    return match (ty) {
        case UnitType => (ty.toString(), argName)
        case BoolType => (ty.toString(), argName)
        case Int8Type => (ty.toString(), argName)
        case UInt8Type => (ty.toString(), argName)
        case Int16Type => (ty.toString(), argName)
        case UInt16Type => (ty.toString(), argName)
        case Int32Type => (ty.toString(), argName)
        case UInt32Type => (ty.toString(), argName)
        case Int64Type => (ty.toString(), argName)
        case UInt64Type => (ty.toString(), argName)
        case IntNativeType => (ty.toString(), argName)
        case UIntNativeType => (ty.toString(), argName)
        case Float32Type => (ty.toString(), argName)
        case Float64Type => (ty.toString(), argName)
        case CStringType => ("CStringConvertable", "${argName}.asCString()")
        case CFuncType(_, _) => (ty.toString(), argName)
        case VArrayType(_, _) => throw IllegalStateException()
        case StructType(_) => (ty.toString(), "unsafe { ${argName}.getCPointer().read() }")
        case TypeAlias(name) => if (let StructType(sname) <- typeAlias.get(name).getOrDefault {TypeAlias(name)}) {
            getWCAPIArgument(StructType(sname), argName, typeAlias)
        } else {
            (ty.toString(), argName)
        }
        case TemplateType(template, typenames) => match (template) {
            case CPointerType => match (typenames[0]) {
                case UnitType => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case BoolType => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case Int8Type => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case UInt8Type => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case Int16Type => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case UInt16Type => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case Int32Type => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case UInt32Type => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case Int64Type => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case UInt64Type => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case IntNativeType => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case UIntNativeType => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case Float32Type => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case Float64Type => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case CStringType => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case CFuncType(_, _) => ("Ref<${typenames[0]}>", "${argName}.getCPointer()")
                case VArrayType(_, _) => throw IllegalStateException()
                case StructType(_) => (typenames[0].toString(), "${argName}.getCPointer()")
                case TypeAlias(name) =>
                    let alias = typeAlias.get(name) ?? StructType(name)
                    var (newTy, argName) = getWCAPIArgument(TemplateType(CPointerType, [alias]), argName, typeAlias)
                    (newTy.replace(alias.toString(), name), argName)
                case TemplateType(template, typenames) => match (template) {
                    case CPointerType => (ty.toString(), argName)
                }
            }
        }
    }
}

func getWCAPIReturn(ty: CjType, originalReturn: String, typeAlias: HashMap<String, CjType>): (String, String) {
    return match (ty) {
        case UnitType => (ty.toString(), originalReturn)
        case BoolType => (ty.toString(), originalReturn)
        case Int8Type => (ty.toString(), originalReturn)
        case UInt8Type => (ty.toString(), originalReturn)
        case Int16Type => (ty.toString(), originalReturn)
        case UInt16Type => (ty.toString(), originalReturn)
        case Int32Type => (ty.toString(), originalReturn)
        case UInt32Type => (ty.toString(), originalReturn)
        case Int64Type => (ty.toString(), originalReturn)
        case UInt64Type => (ty.toString(), originalReturn)
        case IntNativeType => (ty.toString(), originalReturn)
        case UIntNativeType => (ty.toString(), originalReturn)
        case Float32Type => (ty.toString(), originalReturn)
        case Float64Type => (ty.toString(), originalReturn)
        case CStringType => ("String", "CString(${originalReturn}).toString()")
        case CFuncType(_, _) => (ty.toString(), originalReturn)
        case VArrayType(_, _) => throw IllegalStateException()
        case StructType(_) => (ty.toString(), "${ty}(value: Some(${originalReturn}))")
        case TypeAlias(name) => if (let StructType(sname) <- typeAlias.get(name).getOrDefault {TypeAlias(name)}) {
            getWCAPIReturn(StructType(sname), originalReturn, typeAlias)
        } else {
            (ty.toString(), originalReturn)
        }
        case TemplateType(template, typenames) => match (template) {
            case CPointerType => match (typenames[0]) {
                case UnitType => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case BoolType => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case Int8Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case UInt8Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case Int16Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case UInt16Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case Int32Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case UInt32Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case Int64Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case UInt64Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case IntNativeType => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case UIntNativeType => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case Float32Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case Float64Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case CStringType => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case CFuncType(_, _) => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${originalReturn}, count: -1, owned: false)")
                case VArrayType(_, _) => throw IllegalStateException()
                case StructType(_) => (typenames[0].toString(), "${typenames[0]}(${originalReturn}, owned: false)")
                case TypeAlias(name) =>
                    let alias = typeAlias.get(name) ?? StructType(name)
                    var (newTy, newRet) = getWCAPIReturn(TemplateType(CPointerType, [alias]), originalReturn, typeAlias)
                    (newTy.replace(alias.toString(), name), newRet)
                case TemplateType(template, typenames) => match (template) {
                    case CPointerType => (ty.toString(), originalReturn)
                }
            }
        }
    }
}

func getWCAPIMemberAccess(ty: CjType, accessCall: String, writeArg: String, typeAlias: HashMap<String, CjType>,
    makeCType!: (String) -> String): (String, String, String) {
    func rename(ty: CjType, trans: Bool): CjType {
        return match (ty) {
            case CFuncType(params, ret) => CFuncType(
                ArrayList<(String, CjType)>.fromIterator(
                    params |> map {
                    pair: (String, CjType) =>
                    let (pname, ptype) = pair
                    (pname, rename(ptype, true))
                }).toArray(),
                rename(ret, true)
            )
            case VArrayType(ty, size) => CjType.VArrayType(rename(ty, true), size)
            case StructType(name) => StructType(if (trans) {
                makeCType(name)
            } else {
                name
            })
            case TypeAlias(name) => if (let StructType(sname) <- typeAlias.get(name).getOrDefault {TypeAlias(name)}) {
                rename(StructType(sname), trans)
            } else {
                ty
            }
            case TemplateType(template, typenames) => match (template) {
                case CPointerType => TemplateType(CPointerType, [rename(typenames[0], true)])
            }
            case _ => ty
        }
    }

    return match (ty) {
        case UnitType => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case BoolType => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case Int8Type => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case UInt8Type => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case Int16Type => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case UInt16Type => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case Int32Type => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case UInt32Type => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case Int64Type => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case UInt64Type => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case IntNativeType => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case UIntNativeType => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case Float32Type => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case Float64Type => (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case CStringType => ("String", "CString(${accessCall}.read()).toString()",
            "${accessCall}.write(${writeArg}.asCString())")
        case CFuncType(_, _) => (rename(ty, false).toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        case VArrayType(eleTy, size) =>
            var (t, read, write) = ("Ref<${rename(eleTy, false)}>",
                "Ref<${rename(eleTy, false)}>.unsafeMake(${accessCall}.read(), count: ${size}, owned: false)",
                "throw UnsupportedException(\"C array member can not be set \${${writeArg}}\");")
            if (let StructType(name) <- eleTy) {
                t = name
                read = "${name}(${accessCall}.read(), count: ${size}, owned: false)"
                write = "throw UnsupportedException(\"C array member can not be set \${${writeArg}}\");"
            } else if (let TypeAlias(name) <- eleTy) {
                if (let StructType(sname) <- typeAlias.get(name).getOrDefault {TypeAlias(name)}) {
                    t = name
                    read = "${sname}(${accessCall}.read(), count: ${size}, owned: false)"
                    write = "throw UnsupportedException(\"C array member can not be set \${${writeArg}}\");"
                }
            }
            (t, read, write)
        case StructType(_) => (ty.toString(), "${ty}(${accessCall}, owned: false)",
            "${accessCall}.write(${writeArg}.getCPointer().read())")
        case TypeAlias(name) => if (let StructType(sname) <- typeAlias.get(name).getOrDefault {TypeAlias(name)}) {
            getWCAPIMemberAccess(StructType(sname), accessCall, writeArg, typeAlias, makeCType: makeCType)
        } else {
            (ty.toString(), "${accessCall}.read()", "${accessCall}.write(${writeArg})")
        }
        case TemplateType(template, typenames) => match (template) {
            case CPointerType => match (typenames[0]) {
                case UnitType => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case BoolType => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case Int8Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case UInt8Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case Int16Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case UInt16Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case Int32Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case UInt32Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case Int64Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case UInt64Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case IntNativeType => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case UIntNativeType => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case Float32Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case Float64Type => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case CStringType => ("Ref<${typenames[0]}>",
                    "Ref<${typenames[0]}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case CFuncType(_, _) => ("Ref<${rename(typenames[0], false)}>",
                    "Ref<${rename(typenames[0], false)}>.unsafeMake(${accessCall}.read(), count: -1, owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case VArrayType(_, _) => throw IllegalStateException()
                case StructType(_) => (typenames[0].toString(), "${typenames[0]}(${accessCall}.read(), owned: false)",
                    "${accessCall}.write(${writeArg}.getCPointer())")
                case TypeAlias(name) =>
                    let alias = typeAlias.get(name) ?? StructType(name)
                    var (newTy, read, write) = getWCAPIMemberAccess(TemplateType(CPointerType, [alias]), accessCall,
                        writeArg, typeAlias, makeCType: makeCType)
                    (newTy.replace(alias.toString(), name), read, write)
                case TemplateType(template, typenames) => match (template) {
                    case CPointerType => (rename(ty, false).toString(), "${accessCall}.read()",
                        "${accessCall}.write(${writeArg})")
                }
            }
        }
    }
}

struct FunctionDesc {
    FunctionDesc(
        let originalFunctionDecl!: String,
        let cimguiFunctionDecl!: String
    ) {
    }
}

struct StructDesc {
    StructDesc(
        let members!: ArrayList<(String, String, String)>,
        let functions!: ArrayList<(String, FunctionDesc)>
    ) {
    }
}

class APIInfo {
    private let argMappingOfGlobalFunctions = TreeMap<String, String>() // original type => cangjie type
    private let retMappingOfGlobalFunctions = TreeMap<String, String>() // original type => cangjie type
    private let descOfGlobalFunctions = TreeMap<String, FunctionDesc>() // cangjie signature => desc of this function
    private let uncoveredGlobalFunctions = ArrayList<String>()
    private let mappingOfStructMembers = TreeMap<String, String>() // original type => cangjie type
    private let argMappingOfStructFunctions = TreeMap<String, String>() // original type => cangjie type
    private let retMappingOfStructFunctions = TreeMap<String, String>() // original type => cangjie type
    private let descOfStructs = TreeMap<String, StructDesc>() // cangjie signature => desc of this function
    private let uncoveredStructs = ArrayList<String>()

    func updateArgMappingForGlobalFunction(ori: String, cj: String) {
        argMappingOfGlobalFunctions.put(ori, cj)
    }

    func updateRetMappingForGlobalFunction(ori: String, cj: String) {
        retMappingOfGlobalFunctions.put(ori, cj)
    }

    func addDescForGlobalFunction(cjSig: String, desc: FunctionDesc) {
        descOfGlobalFunctions.put(cjSig, desc)
    }

    func addUncoveredGlobalFunction(fn: String) {
        uncoveredGlobalFunctions.append(fn)
    }

    func updateMappingForStructMembers(ori: String, cj: String) {
        mappingOfStructMembers.put(ori, cj)
    }

    func updateArgMappingForStructFunction(ori: String, cj: String) {
        argMappingOfStructFunctions.put(ori, cj)
    }

    func updateRetMappingForStructFunction(ori: String, cj: String) {
        retMappingOfStructFunctions.put(ori, cj)
    }

    func addMemberDescForStruct(structName: String, member: (String, String, String)) {
        if (descOfStructs.contains(structName)) {
            descOfStructs[structName].members.append(member)
        } else {
            descOfStructs.put(
                structName,
                StructDesc(
                    members: ArrayList<(String, String, String)>([member]),
                    functions: ArrayList<(String, FunctionDesc)>()
                )
            )
        }
    }

    func addMethodDescForStruct(structName: String, md: (String, FunctionDesc)) {
        if (descOfStructs.contains(structName)) {
            descOfStructs[structName].functions.append(md)
        } else {
            descOfStructs.put(
                structName,
                StructDesc(
                    members: ArrayList<(String, String, String)>(),
                    functions: ArrayList<(String, FunctionDesc)>([md])
                )
            )
        }
    }

    func addUncoveredStruct(structName: String) {
        uncoveredStructs.append(structName)
    }

    func generateDocumentForGlobalFunctions<T>(os: StringWriter<T>) where T <: OutputStream {
        os.writeln("# Global Functions")
        os.writeln()
        os.writeln("## Parameter Type Mapping Table")
        os.writeln()
        os.writeln("| Original Type | Cangjie Type |")
        os.writeln("|---------------|--------------|")
        for ((ori, cj) in argMappingOfGlobalFunctions) {
            os.writeln("| `${ori}` | `${cj.replace("`", "")}` |")
        }
        os.writeln()
        os.writeln("## Return Type Mapping Table")
        os.writeln()
        os.writeln("| Original Type | Cangjie Type |")
        os.writeln("|---------------|--------------|")
        for ((ori, cj) in retMappingOfGlobalFunctions) {
            os.writeln("| `${ori}` | `${cj.replace("`", "")}` |")
        }
        os.writeln()
        os.writeln("## All Functions")
        for ((fn, desc) in descOfGlobalFunctions) {
            os.writeln()
            os.writeln("### `${fn.replace("`", "")}`")
            os.writeln("* original function: `${desc.originalFunctionDecl}`")
            os.writeln("* cimgui function: `${desc.cimguiFunctionDecl}`")
        }
        os.writeln()
        os.writeln("## Uncovered Functions")
        os.writeln()
        for (fn in uncoveredGlobalFunctions) {
            os.writeln("* `${fn}`")
        }
    }

    func generateDocumentForGlobalFunctions(filename: String) {
        try (fp = File(filename, OpenOption.CreateOrTruncate(false))) {
            try (sw = StringWriter(fp)) {
                generateDocumentForGlobalFunctions(sw)
            }
        }
    }

    func generateDocumentForStructs<T>(os: StringWriter<T>) where T <: OutputStream {
        /*
        # Structs

        ## Member Variable Type Mapping Table

        ## Member/Static Function Parameter Type Mapping Table

        ## Member/Static Function Return Type Mapping Table

        ## All Struct Wrappers

        ### `public class XXXX`
        #### members:
         * YYYY: YYYY_TYPE (ORIGINAL_YYYY_TYPE)
         * ...
        #### functions:
         * Ret func(p0: P0, ...)
         * original function: xxx
         * cimgui function: xxx

        ## Uncovered Structs

         */
        os.writeln("# Structs")
        os.writeln()
        os.writeln("## Member Variable Type Mapping Table")
        os.writeln()
        os.writeln("| Original Type | Cangjie Type |")
        os.writeln("|---------------|--------------|")
        for ((ori, cj) in mappingOfStructMembers) {
            os.writeln("| `${ori}` | `${cj.replace("`", "")}` |")
        }
        os.writeln()
        os.writeln("## Member/Static Function Parameter Type Mapping Table")
        os.writeln()
        os.writeln("| Original Type | Cangjie Type |")
        os.writeln("|---------------|--------------|")
        for ((ori, cj) in argMappingOfStructFunctions) {
            os.writeln("| `${ori}` | `${cj.replace("`", "")}` |")
        }
        os.writeln()
        os.writeln("## Member/Static Function Return Type Mapping Table")
        os.writeln()
        os.writeln("| Original Type | Cangjie Type |")
        os.writeln("|---------------|--------------|")
        for ((ori, cj) in retMappingOfStructFunctions) {
            os.writeln("| `${ori}` | `${cj.replace("`", "")}` |")
        }
        os.writeln()
        os.writeln("## All Struct Wrappers")
        for ((fn, desc) in descOfStructs) {
            os.writeln()
            os.writeln("### class `${fn.replace("`", "")}`")
            os.writeln()
            os.writeln("#### members:")
            for ((name, ty, cty) in desc.members) {
                os.writeln("* `${name}`: `${ty}` // `${cty}`")
            }
            os.writeln()
            os.writeln("#### functions:")
            for ((name, fn) in desc.functions) {
                os.writeln("* `${name}`")
                os.writeln("    * original function: `${fn.originalFunctionDecl}`")
                os.writeln("    * cimgui function: `${fn.cimguiFunctionDecl}`")
            }
        }
        os.writeln()
        os.writeln("## Uncovered Structs")
        os.writeln(
            "These structs don't have a wrapper class; instead, they are typedef'd as `Unit`, " +
            "which allows their pointers (`CPointer<Struct>`) to be used as function parameters/return " +
            "but prevents direct access to their members.")
        os.writeln()
        for (s in uncoveredStructs) {
            os.writeln("* `${s}`")
        }
    }

    func generateDocumentForStructs(filename: String) {
        try (fp = File(filename, OpenOption.CreateOrTruncate(false))) {
            try (sw = StringWriter(fp)) {
                generateDocumentForStructs(sw)
            }
        }
    }
}

func transLiteralFromCToWCAPI(cArg: String, cType: String, typeAlias: HashMap<String, CjType>): String {
    // NOTE: simple but enough for imgui
    // FIXME: fix hardcode if needed

    let getTypeName = {
        cjType: CjType => return match (cjType) {
            case TypeAlias(name) => typeAlias.get(name)?.toString() ?? name
            case _ => cjType.toString()
        }
    }

    let cjType = CjType.fromCType(cType, cArrayAsPointer: true)

    // FLT_MAX
    if (cArg == "FLT_MAX") {
        return "Float32.Max"
    }

    // sizeof(float)
    if (cArg == "sizeof(float)") {
        return "${getTypeName(cjType)}(sizeOf<Float32>())"
    }

    // NULL
    if (cArg == "NULL") {
        return match (cType.replace("const ", "")) {
            case "ImFontAtlas*" => "ImFontAtlas.null()"
            case "ImFontConfig*" => "ImFontConfig.null()"
            case "ImGuiContext*" => "null<ImGuiContext>()"
            case "ImGuiInputTextCallback" => "ImGuiInputTextCallbackNull"
            case "ImGuiSizeCallback" => "ImGuiSizeCallbackNull"
            case "ImGuiStyle*" => "ImGuiStyle.null()"
            case "ImGuiViewport*" => "ImGuiViewport.null()"
            case "ImGuiWindowClass*" => "ImGuiWindowClass.null()"
            case "ImRect*" => "ImRect.null()"
            case "ImVec2*" => "ImVec2.null()"
            case "ImVec4*" => "ImVec4.null()"
            case "ImWchar*" => "null<ImWchar>()"
            case "bool*" => "null<Bool>()"
            case "char*" => "null<UInt8>()"
            case "char**" => "null<CPointer<UInt8>>()"
            case "float*" => "null<Float32>()"
            case "int*" => "null<Int32>()"
            case "size_t*" => "null<UIntNative>()"
            case "void*" => "null<Unit>()"
            case _ => throw IllegalArgumentException("unknow type for NULL: `${cType}`")
        }
    }

    if (cArg == "ImVec2(-FLT_MIN,0)") {
        return "ImVec2(-Float32.Min, 0.0)"
    }

    if (cArg == "ImVec2(0,0)") {
        return "ImVec2(0.0, 0.0)"
    }

    if (cArg == "ImVec2(0,1)") {
        return "ImVec2(0.0, 1.0)"
    }

    if (cArg == "ImVec2(0.0f,0.0f)") {
        return "ImVec2(0.0, 0.0)"
    }

    if (cArg == "ImVec2(1,0)") {
        return "ImVec2(1.0, 0.0)"
    }

    if (cArg == "ImVec2(1,1)") {
        return "ImVec2(1.0, 1.0)"
    }

    if (cArg == "ImVec4(0,0,0,0)") {
        return "ImVec4(0.0, 0.0, 0.0, 0.0)"
    }

    if (cArg == "ImVec4(1,1,1,1)") {
        return "ImVec4(1.0, 1.0, 1.0, 1.0)"
    }

    // number
    let numberArg = cArg.trimRight("f").trimLeft("+")
    if (Int64.tryParse(numberArg).isSome() || Float64.tryParse(numberArg).isSome()) {
        return "${getTypeName(cjType)}(${numberArg})"
    }

    // string, true, false, enum
    return cArg
}
