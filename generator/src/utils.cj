package cimgui_generator

const AUTOGENERATED_FILE_HEAD_COMMENTS = """
// +----------------------------------------------------+
// + THIS FILE IS AUTO-GENERATED BY `cimgui_generator`. +
// +      FROM: https://github.com/PGZXB/imgui.cj       +
// +------------------- DO NOT EDIT. -------------------+"""

func readJsonFile(path: String): JsonValue {
    return JsonValue.fromStr(String.fromUtf8(File.openRead(path).readToEnd()))
}

let cjBasicTypeOfCType = HashMap<String, CjType>(
    [
        ("void", UnitType),
        ("bool", BoolType),
        ("signed char", Int8Type),
        ("char", UInt8Type),
        ("unsigned char", UInt8Type),
        ("int8_t", Int8Type),
        ("uint8_t", UInt8Type),
        ("signed short", Int16Type),
        ("short", Int16Type),
        ("int16_t", Int16Type),
        ("unsigned short", Int16Type),
        ("uint16_t", UInt16Type),
        ("signed int", Int32Type),
        ("int", Int32Type),
        ("int32_t", Int32Type),
        ("unsigned int", Int32Type),
        ("uint32_t", UInt32Type),
        ("unsigned int", Int32Type),
        ("signed long long", Int64Type),
        ("int64_t", Int64Type),
        ("unsigned long long", Int64Type),
        ("uint64_t", UInt64Type),
        ("ssize_t", IntNativeType),
        ("size_t", UIntNativeType),
        ("float", Float32Type),
        ("double", Float64Type),
        ("const char*", CStringType),
        ("FILE", UnitType) // FILE* -> CPointer<Unit>
    ]
)

enum CjTemplateType <: ToString {
    | CPointerType

    public func toString(): String {
        return match (this) {
            case CPointerType => "CPointer"
        }
    }
}

// NOTE: Only for this project, not complete
enum CjType <: ToString {
    | UnitType
    | BoolType
    | Int8Type
    | UInt8Type
    | Int16Type
    | UInt16Type
    | Int32Type
    | UInt32Type
    | Int64Type
    | UInt64Type
    | IntNativeType
    | UIntNativeType
    | Float32Type
    | Float64Type
    | CStringType
    | CFuncType(Array<(String, CjType)>, CjType) // param-types, ret-type
    | VArrayType(CjType, Int64)
    | StructType(String)
    | TypeAlias(String) // type a = b
    | TemplateType(CjTemplateType, Array<CjType>)

    func getPointer(): CjType {
        return TemplateType(CPointerType, [this])
    }

    func getVArray(size: Int64): CjType {
        return VArrayType(this, size)
    }

    public func toString(): String {
        return match (this) {
            case UnitType => "Unit"
            case BoolType => "Bool"
            case Int8Type => "Int8"
            case UInt8Type => "UInt8"
            case Int16Type => "Int16"
            case UInt16Type => "UInt16"
            case Int32Type => "Int32"
            case UInt32Type => "UInt32"
            case Int64Type => "Int64"
            case UInt64Type => "UInt64"
            case IntNativeType => "IntNative"
            case UIntNativeType => "UIntNative"
            case Float32Type => "Float32"
            case Float64Type => "Float64"
            case CStringType => "CString"
            case CFuncType(pTypes, retType) =>
                // CFunc<(argName: CPointer<Int8>) -> Unit>
                let sb = StringBuilder()
                sb.append("CFunc<(")
                for ((i, (n, t)) in withIndex(pTypes)) {
                    sb.append("${n}: ${t}")
                    if (i != pTypes.size - 1) {
                        sb.append(", ")
                    }
                }
                sb.append(") -> ${retType}")
                sb.append(">")
                sb.toString()
            case VArrayType(ty, size) => "VArray<${ty}, \$${size}>"
            case StructType(name) => name
            case TypeAlias(name) => name
            case TemplateType(ty, tyArgs) =>
                // CPointer<T>
                let sb = StringBuilder()
                sb.append("${ty}<")
                for ((i, t) in withIndex(tyArgs)) {
                    sb.append(t)
                    if (i != tyArgs.size - 1) {
                        sb.append(", ")
                    }
                }
                sb.append(">")
                sb.toString()
        }
    }

    func getDefaultValueLiteral(typeAlias!: ?HashMap<String, CjType> = None): String {
        return match (this) {
            case BoolType => "false"
            case Int8Type => "0"
            case UInt8Type => "0"
            case Int16Type => "0"
            case UInt16Type => "0"
            case Int32Type => "0"
            case UInt32Type => "0"
            case Int64Type => "0"
            case UInt64Type => "0"
            case IntNativeType => "0"
            case UIntNativeType => "0"
            case Float32Type => "0.0f32"
            case Float64Type => "0.0f64"
            case CStringType => "CString(CPointer<UInt8>())"
            case CFuncType(pTypes, retType) => "${this}(CPointer<Unit>())"
            case VArrayType(ty, size) => "${this}(item: ${ty.getDefaultValueLiteral(typeAlias: typeAlias)})"
            case StructType(name) => "${this}()"
            case TypeAlias(name) => if (let Some(td) <- typeAlias) {
                if (let None <- td.get(name)) {
                    println("TODO: ${name} --> ${td.get(name)}")
                }
                td.get(name)?.getDefaultValueLiteral(typeAlias: typeAlias) ?? "${this}()"
            } else {
                "${this}()"
            }
            case TemplateType(ty, tyArgs) => "${this}()"
            case _ => throw UnsupportedException("${this} do not have default value literal")
        }
    }

    static func fromCType(ty: String, size!: ?Int64 = None): CjType {
        return getCjTypeOfCType(ty, size: size)
    }

    private static func tryGetCjTypeOfBuiltinCType(ty: String): ?CjType {
        return cjBasicTypeOfCType.get(ty)
    }

    private static func tryGetCjTypeOfCPointer(ty: String): ?CjType {
        if (!ty.endsWith("*")) {
            return None
        }

        let baseTy = ty[0..ty.size - 1].trimLeft("const").trimAscii()
        let baseCjTy = getCjTypeOfCType(baseTy)
        return baseCjTy.getPointer()
    }

    private static func tryGetCjTypeOfCExplicitStructType(ty: String): ?CjType {
        if (!ty.startsWith("struct ")) {
            return None
        }
        return StructType(ty.trimLeft("struct "))
    }

    private static func tryGetCjTypeOfCFunc(ty: String): ?CjType {
        // void(*)(const ImDrawList* parent_list,const ImDrawCmd* cmd);
        if (!ty.contains("(*)(")) {
            return None
        }

        if (ty.count("(*)(") != 1) {
            throw UnsupportedException("Only one '(*)(\"' is allowed")
        }

        let retAndParams = ty.trimRight(";").trimRight(")").split("(*)(")
        let retCType = retAndParams[0].trimAscii()
        let paramCTypes = retAndParams[1].split(",")

        return CFuncType(
            Array<(String, CjType)>(paramCTypes.size) {
                i =>
                let lastSpacePos = paramCTypes[i].lastIndexOf(" ").getOrThrow()
                return (paramCTypes[i][lastSpacePos + 1..].trimAscii(), CjType.fromCType(
                        paramCTypes[i][..lastSpacePos].trimAscii()))
            },
            CjType.fromCType(retCType)
        )
    }

    private static func getCjTypeOfCType(ty: String, size!: ?Int64 = None): CjType {
        let cjTy: CjType = tryGetCjTypeOfBuiltinCType(ty) ?? tryGetCjTypeOfCPointer(ty) ?? tryGetCjTypeOfCFunc(ty) ??
            tryGetCjTypeOfCExplicitStructType(ty) ?? TypeAlias(ty)

        return match (size) {
            case Some(size) => cjTy.getVArray(size)
            case None => cjTy
        }
    }
}

func getCjStructMemberName(mdef: StructMemberDef): String {
    if (let Some(_) <- mdef.size) {
        return mdef.name[0..mdef.name.indexOf("[").getOrThrow()]
    }

    return mdef.name
}
