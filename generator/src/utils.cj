package cimgui_generator

from std import collection.{any, HashSet}

const AUTOGENERATED_FILE_HEAD_COMMENTS = """
// +----------------------------------------------------+
// + THIS FILE IS AUTO-GENERATED BY `cimgui_generator`. +
// +      FROM: https://github.com/PGZXB/imgui4cj       +
// +------------------- DO NOT EDIT. -------------------+"""
const CAPI_IMPL_SYMBOL_PREFIX = "_capi_"

func readJsonFile(path: String): JsonValue {
    return JsonValue.fromStr(String.fromUtf8(File.openRead(path).readToEnd()))
}

let CJ_BASIC_TYPE_OF_C_TYPE = HashMap<String, CjType>(
    [
        ("void", UnitType),
        ("bool", BoolType),
        ("signed char", Int8Type),
        ("char", UInt8Type),
        ("unsigned char", UInt8Type),
        ("int8_t", Int8Type),
        ("uint8_t", UInt8Type),
        ("signed short", Int16Type),
        ("short", Int16Type),
        ("int16_t", Int16Type),
        ("unsigned short", Int16Type),
        ("uint16_t", UInt16Type),
        ("signed int", Int32Type),
        ("int", Int32Type),
        ("int32_t", Int32Type),
        ("unsigned int", Int32Type),
        ("uint32_t", UInt32Type),
        ("unsigned int", Int32Type),
        ("signed long long", Int64Type),
        ("int64_t", Int64Type),
        ("unsigned long long", Int64Type),
        ("uint64_t", UInt64Type),
        ("ssize_t", IntNativeType),
        ("size_t", UIntNativeType),
        ("float", Float32Type),
        ("double", Float64Type),
        ("char*", CStringType),
        ("FILE", UnitType) // FILE* -> CPointer<Unit>
    ]
)

enum CjTemplateType <: ToString {
    | CPointerType

    public func toString(): String {
        return match (this) {
            case CPointerType => "CPointer"
        }
    }
}

// NOTE: Only for this project, not complete
enum CjType <: ToString {
    | UnitType
    | BoolType
    | Int8Type
    | UInt8Type
    | Int16Type
    | UInt16Type
    | Int32Type
    | UInt32Type
    | Int64Type
    | UInt64Type
    | IntNativeType
    | UIntNativeType
    | Float32Type
    | Float64Type
    | CStringType
    | CFuncType(Array<(String, CjType)>, CjType) // param-types, ret-type
    | VArrayType(CjType, Int64)
    | StructType(String)
    | TypeAlias(String) // type a = b
    | TemplateType(CjTemplateType, Array<CjType>)

    func getPointer(): CjType {
        return TemplateType(CPointerType, [this])
    }

    func getVArray(size: Int64): CjType {
        return VArrayType(this, size)
    }

    public func toString(): String {
        return match (this) {
            case UnitType => "Unit"
            case BoolType => "Bool"
            case Int8Type => "Int8"
            case UInt8Type => "UInt8"
            case Int16Type => "Int16"
            case UInt16Type => "UInt16"
            case Int32Type => "Int32"
            case UInt32Type => "UInt32"
            case Int64Type => "Int64"
            case UInt64Type => "UInt64"
            case IntNativeType => "IntNative"
            case UIntNativeType => "UIntNative"
            case Float32Type => "Float32"
            case Float64Type => "Float64"
            case CStringType => "CString"
            case CFuncType(pTypes, retType) =>
                // CFunc<(argName: CPointer<Int8>) -> Unit>
                let sb = StringBuilder()
                sb.append("CFunc<(")
                for ((i, (n, t)) in withIndex(pTypes)) {
                    sb.append("${n}: ${t}")
                    if (i != pTypes.size - 1) {
                        sb.append(", ")
                    }
                }
                sb.append(") -> ${retType}")
                sb.append(">")
                sb.toString()
            case VArrayType(ty, size) => "VArray<${ty}, \$${size}>"
            case StructType(name) => name
            case TypeAlias(name) => name
            case TemplateType(ty, tyArgs) =>
                // CPointer<T>
                let sb = StringBuilder()
                sb.append("${ty}<")
                for ((i, t) in withIndex(tyArgs)) {
                    sb.append(t)
                    if (i != tyArgs.size - 1) {
                        sb.append(", ")
                    }
                }
                sb.append(">")
                sb.toString()
        }
    }

    func getDefaultValueLiteral(typeAlias!: ?HashMap<String, CjType> = None): String {
        return match (this) {
            case BoolType => "false"
            case Int8Type => "0"
            case UInt8Type => "0"
            case Int16Type => "0"
            case UInt16Type => "0"
            case Int32Type => "0"
            case UInt32Type => "0"
            case Int64Type => "0"
            case UInt64Type => "0"
            case IntNativeType => "0"
            case UIntNativeType => "0"
            case Float32Type => "0.0f32"
            case Float64Type => "0.0f64"
            case CStringType => "CString(CPointer<UInt8>())"
            case CFuncType(pTypes, retType) => "${this}(CPointer<Unit>())"
            case VArrayType(ty, size) => "${this}(item: ${ty.getDefaultValueLiteral(typeAlias: typeAlias)})"
            case StructType(name) => "${this}()"
            case TypeAlias(name) => if (let Some(td) <- typeAlias) {
                td.get(name)?.getDefaultValueLiteral(typeAlias: typeAlias) ?? "${this}()"
            } else {
                "${this}()"
            }
            case TemplateType(ty, tyArgs) => "${this}()"
            case _ => throw UnsupportedException("${this} do not have default value literal")
        }
    }

    static func fromCType(ty: String, size!: ?Int64 = None, cArrayAsPointer!: Bool = false): CjType {
        return getCjTypeOfCType(ty, size: size, cArrayAsPointer: cArrayAsPointer)
    }

    private static func tryGetCjTypeOfBuiltinCType(ty: String): ?CjType {
        return CJ_BASIC_TYPE_OF_C_TYPE.get(ty) ?? CJ_BASIC_TYPE_OF_C_TYPE.get(ty)
    }

    private static func tryGetCjTypeOfCArrayType(ty: String, cArrayAsPointer: Bool): ?CjType {
        if (!ty.endsWith("]") || ty.count("]") != 1 || ty.count("[") != 1) {
            return None
        }

        let leftPPos = ty.indexOf("[").getOrThrow()
        let size = ty[leftPPos + 1..].trimRight("]")
        let cjTy = fromCType(ty[0..leftPPos])
        return if (size.isEmpty() || cArrayAsPointer) {
            cjTy.getPointer()
        } else {
            cjTy.getVArray(Int64.parse(size))
        }
    }

    private static func tryGetCjTypeOfCPointer(ty: String): ?CjType {
        if (!ty.endsWith("*")) {
            return None
        }

        let baseTy = ty[0..ty.size - 1].trimLeft("const").trimAscii()
        let baseCjTy = getCjTypeOfCType(baseTy)
        return baseCjTy.getPointer()
    }

    private static func tryGetCjTypeOfCExplicitStructType(ty: String): ?CjType {
        if (!ty.startsWith("struct ")) {
            return None
        }
        return StructType(ty.trimLeft("struct "))
    }

    private static func tryGetCjTypeOfCFunc(ty: String): ?CjType {
        // void(*)(const ImDrawList* parent_list,const ImDrawCmd* cmd);
        if (!ty.contains("(*)(")) {
            return None
        }

        if (ty.count("(*)(") != 1) {
            throw UnsupportedException("Only one '(*)(\"' is allowed")
        }

        let retAndParams = ty.trimRight(";").trimRight(")").split("(*)(")
        let retCType = retAndParams[0].trimAscii()
        let paramCTypes = retAndParams[1].split(",")

        return CFuncType(
            Array<(String, CjType)>(paramCTypes.size) {
                i =>
                let lastSpacePos = paramCTypes[i].lastIndexOf(" ").getOrThrow()
                return (paramCTypes[i][lastSpacePos + 1..].trimAscii(), CjType.fromCType(
                        paramCTypes[i][..lastSpacePos].trimAscii()))
            },
            CjType.fromCType(retCType)
        )
    }

    private static func getCjTypeOfCType(_ty: String, size!: ?Int64 = None, cArrayAsPointer!: Bool = false): CjType {
        let ty = _ty.replace("const ", "").trimAscii().replace(" const", "").trimAscii()
        let cjTy = tryGetCjTypeOfBuiltinCType(ty) ?? tryGetCjTypeOfCArrayType(ty, cArrayAsPointer) ??
            tryGetCjTypeOfCPointer(ty) ?? tryGetCjTypeOfCFunc(ty) ?? tryGetCjTypeOfCExplicitStructType(ty) ?? TypeAlias(
            ty)

        return match (size) {
            case Some(size) => cjTy.getVArray(size)
            case None => cjTy
        }
    }
}

func getCjStructMemberName(mdef: StructMemberDef): String {
    if (let Some(_) <- mdef.size) {
        return mdef.name[0..mdef.name.indexOf("[").getOrThrow()]
    }

    return mdef.name
}

func evalIntConstExprImpl(e: Expr, t: ?HashMap<String, String>): Int64 {
    // simple but enough
    return match (e) {
        case binExpr: BinaryExpr =>
            let left = evalIntConstExprImpl(binExpr.leftExpr, t)
            let right = evalIntConstExprImpl(binExpr.rightExpr, t)
            match (binExpr.op.kind) {
                case ADD => left + right
                case SUB => left - right
                case MUL => left * right
                case DIV => left / right
                case LSHIFT => left << right
                case RSHIFT => left >> right
                case _ => throw UnsupportedException("Unsupported op `${binExpr.op.value}`")
            }
        case uExpr: UnaryExpr =>
            let val = evalIntConstExprImpl(uExpr.expr, t)
            match (uExpr.op.kind) {
                case SUB => -val
                case _ => throw UnsupportedException("Unsupported op `${uExpr.op.value}`")
            }
        case litExpr: LitConstExpr => Int64.parse(litExpr.literal.value)
        case refExpr: RefExpr =>
            let constantTable = t.getOrThrow {IllegalArgumentException("constants table are not provided but required")}
            let consantValue = constantTable.get(refExpr.identifier.value).getOrThrow {
                IllegalArgumentException("`${refExpr.identifier.value}` are not found")
            }
            Int64.parse(consantValue)
        case parenExpr: ParenExpr => evalIntConstExprImpl(parenExpr.parenthesizedExpr, t)
        case _ => throw UnsupportedException("Unsupported `${e.toTokens()}` expression")
    }
}

func evalIntConstExpr(e: String, constantTable!: ?HashMap<String, String> = None) {
    let tokens = cangjieLex(e)
    let expr = parseExpr(tokens)
    return evalIntConstExprImpl(expr, constantTable)
}

func tryConvertTemplateTypename(ty: String): ?String {
    let leftCnt = ty.count("<")
    let rightCnt = ty.count("<")

    if (leftCnt == 0 || rightCnt == 0) {
        return Option<String>.None
    }

    if (leftCnt != 1 || rightCnt != 1) {
        throw UnsupportedException("Only support `Type<T, N>`-like template types")
    }

    let converted = StringBuilder()
    for (r in ty.trimRight(">").runes()) {
        if (r == '<') {
            converted.append('_')
        } else if (r == '>') {
            throw IllegalStateException()
        } else if (r == '_' || r.isAsciiNumberOrLetter()) {
            converted.append(r)
        } else if (r == '-') {
            converted.append("less")
        } else if (r == '*') {
            converted.append("Ptr")
        } else if (r == ',') {
            converted.append("__")
        } else {
            converted.append('_')
        }
    }
    return converted.toString()
}

let CJ_KEYWORKS_TABLE = HashSet<String>(
    [
        "as",
        "abstract",
        "break",
        "Bool",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "Char",
        "do",
        "else",
        "enum",
        "extend",
        "for",
        "from",
        "func",
        "false",
        "finally",
        "foreign",
        "Float16",
        "Float32",
        "Float64",
        "if",
        "in",
        "is",
        "init",
        "import",
        "interface",
        "Int8",
        "Int16",
        "Int32",
        "Int64",
        "IntNative",
        "let",
        "mut",
        "main",
        "macro",
        "match",
        "Nothing",
        "open",
        "operator",
        "override",
        "prop",
        "public",
        "package",
        "private",
        "protected",
        "quote",
        "redef",
        "return",
        "spawn",
        "super",
        "static",
        "struct",
        "synchronized",
        "try",
        "this",
        "true",
        "type",
        "throw",
        "This",
        "unsafe",
        "Unit",
        "UInt8",
        "UInt16",
        "UInt32",
        "UInt64",
        "UIntNative",
        "var",
        "VArray",
        "where",
        "while"
    ]
)

func getValidCjIdentifier(id: String): String {
    // simple but enough

    if (id.startsWith("`") && id.endsWith("`")) {
        return id
    }

    if (id.runes() |> any {
        e: Rune => !e.isAsciiNumberOrLetter() && e != '_'
    }) {
        throw UnsupportedException("unsupported id to be converted: ${id}")
    }

    return if (CJ_KEYWORKS_TABLE.contains(id)) {
        "`${id}`"
    } else {
        id
    }
}

func getWCAPIArgument(ty: CjType, argName_: String, typeAlias: HashMap<String, CjType>): (String, String) {
    let argName = getValidCjIdentifier(argName_)
    return match (ty) {
        case UnitType => (ty.toString(), argName)
        case BoolType => (ty.toString(), argName)
        case Int8Type => (ty.toString(), argName)
        case UInt8Type => (ty.toString(), argName)
        case Int16Type => (ty.toString(), argName)
        case UInt16Type => (ty.toString(), argName)
        case Int32Type => (ty.toString(), argName)
        case UInt32Type => (ty.toString(), argName)
        case Int64Type => (ty.toString(), argName)
        case UInt64Type => (ty.toString(), argName)
        case IntNativeType => (ty.toString(), argName)
        case UIntNativeType => (ty.toString(), argName)
        case Float32Type => (ty.toString(), argName)
        case Float64Type => (ty.toString(), argName)
        case CStringType => ("CStringConvertable", "${argName}.asCString()")
        case CFuncType(_, _) => (ty.toString(), argName)
        case VArrayType(_, _) => throw IllegalStateException()
        case StructType(_) => (ty.toString(), argName)
        // case StructType(_) => (ty.toString(), "${argName}.getPointer()")
        case TypeAlias(name) => if (let StructType(sname) <- typeAlias.get(name).getOrDefault {TypeAlias(name)}) {
            getWCAPIArgument(StructType(sname), argName, typeAlias)
        } else {
            (ty.toString(), argName)
        }
        case TemplateType(template, typenames) => match (template) {
            case CPointerType => match (typenames[0]) {
                case UnitType => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case BoolType => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case Int8Type => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case UInt8Type => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case Int16Type => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case UInt16Type => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case Int32Type => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case UInt32Type => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case Int64Type => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case UInt64Type => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case IntNativeType => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case UIntNativeType => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case Float32Type => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case Float64Type => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case CStringType => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case CFuncType(_, _) => ("Value<${typenames[0]}>", "${argName}.getCPointer()")
                case VArrayType(_, _) => throw IllegalStateException()
                case StructType(_) => (ty.toString(), argName)
                // case StructType(_) => (typenames[0].toString(), "${argName}.getCPointer()")
                case TypeAlias(name) => if (let StructType(sname) <- typeAlias.get(name).getOrDefault {TypeAlias(name)}) {
                    getWCAPIArgument(TemplateType(CPointerType, [StructType(sname)]), argName, typeAlias)
                } else {
                    (ty.toString(), argName)
                }
                case TemplateType(template, typenames) => match (template) {
                    case CPointerType => (ty.toString(), argName)
                }
            }
        }
    }
}
