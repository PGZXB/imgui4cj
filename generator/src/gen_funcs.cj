package imgui4cj_generator

import std.collection.{ArrayList, HashMap, HashSet, map, filter}
import std.io.{OutputStream, StringWriter}
import std.fs.{File, OpenOption}
import encoding.json.*

struct FuncParameter {
    FuncParameter(let name: String, let ty: String) {
    }
}

struct FuncSignature {
    FuncSignature(let name: String, let params: ArrayList<FuncParameter>, let retType: String, let structName: String,
        let isClassStaticMethod: Bool, let isConstructor: Bool, let isDestructor: Bool, let originalName: String,
        let nonUDT: Bool, let defaultaArgs: HashMap<String, String>, let imguiFuncDecl: String,
        let cimguiFuncDecl: String) {
    }
}

func parseFuncsJson(funcsJson: JsonValue): ArrayList<FuncSignature> {
    let j2map = {
        object: JsonObject =>
        let result = HashMap<String, String>()
        for ((k, v) in object.getFields()) {
            result[k] = v.asString().getValue()
        }
        return result
    }

    let result = ArrayList<FuncSignature>()

    for ((_, fnOverloads) in funcsJson.asObject().getFields()) {
        for (fnSig in fnOverloads.asArray().getItems() |> map {
                item => item.asObject()
            } |> filter {
                item => !(item.get("templated")?.asBool().getValue() ?? false)
            }) {
            if (fnSig.get("constructor")?.asBool().getValue() ?? false) {
                // ret type is `StructType*`
                fnSig.put("ret", JsonString(fnSig["stname"].asString().getValue() + "*"))
            }
            if (fnSig.get("destructor")?.asBool().getValue() ?? false) {
                // ~StructType
                fnSig.put("funcname", JsonString("~" + fnSig["stname"].asString().getValue()))
                fnSig.put("argsoriginal", JsonString("()"))
            }
            if (!fnSig.containsKey("defaults")) {
                fnSig.put("defaults", JsonObject())
            }
            result.append(
                FuncSignature(
                    fnSig["ov_cimguiname"].asString().getValue(), // name
                    ArrayList<FuncParameter>.fromIterator( // params
                        fnSig["argsT"].asArray().getItems() |> map(
                        {
                            item =>
                            let obj = item.asObject()
                            // NOTE: Only for cimgui: avoid using more powerful/complex library
                            var ty = obj["type"].asString().getValue()
                            if (ty == "int(*)(void const*,void const*)") {
                                ty = "int(*)(void const* arg1,void const* arg2)"
                            } else if (ty == "const char*(*)(void*,int)") {
                                ty = "const char*(*)(void* arg1,int arg2)"
                            }
                            return FuncParameter(obj["name"].asString().getValue(), ty)
                        }
                    )),
                    fnSig["ret"].asString().getValue(), // retType
                    fnSig.get("stname")?.asString().getValue() ?? "", // structName
                    fnSig.get("is_static_function")?.asBool().getValue() ?? false, // isClassStaticMethod
                    fnSig.get("constructor")?.asBool().getValue() ?? false, // isConstructor
                    fnSig.get("destructor")?.asBool().getValue() ?? false, // isDestructor
                    fnSig["funcname"].asString().getValue(), // originalName
                    (fnSig.get("nonUDT")?.asInt().getValue() ?? 0) == 1, // nonUDT
                    j2map(fnSig["defaults"].asObject()), // defaultaArgs
                    "${fnSig["ret"].asString().getValue()} ${fnSig["funcname"].asString().getValue()}${fnSig["argsoriginal"].asString().getValue()}", // imguiFuncDecl
                    "${fnSig["ret"].asString().getValue()} ${fnSig["ov_cimguiname"].asString().getValue()}${fnSig["args"].asString().getValue()}" // cimguiFuncDecl
                )
            )
        }
    }

    return result
}

func genFuncsCode<T>(os: StringWriter<T>, pkgName: String, funcs: ArrayList<FuncSignature>) where T <: OutputStream {
    // SOME COMMENTS ....
    //
    // package xxx
    //
    // @C
    // foreign func funcName0(param0: Param0, param1: Param1 ...): RetType
    // 
    // @C
    // ...
    //
    // public func _capi_funcName0(param0: Param0, param1: Param1 ...): RetType {
    //     return unsafe { funcName0(param0, param1 ...) }
    // }

    let symbols = ArrayList<String>()
    os.writeln(AUTOGENERATED_FILE_HEAD_COMMENTS)
    os.writeln()
    os.writeln("package ${pkgName}")
    os.writeln()

    // Gen foreign func decls
    for ((i, fn) in withIndex(funcs)) {
        let fnSb = StringBuilder()
        var hasVaList = false
        fnSb.append("foreign func ${fn.name}(")
        for ((i, p) in withIndex(fn.params)) {
            if (p.ty == "va_list") {
                hasVaList = true
            }
            if (p.name == "..." && p.ty == "...") {
                fnSb.append("...")
            } else {
                fnSb.append("${getValidCjIdentifier(p.name)}: ${CjType.fromCType(p.ty, cArrayAsPointer: true)}")
            }
            if (i != fn.params.size - 1) {
                fnSb.append(", ")
            }
        }
        fnSb.append("): ${CjType.fromCType(fn.retType, cArrayAsPointer: true)}")
        if (hasVaList) {
            os.writeln("// Cangjie does not support `va_list`")
            os.write("// ")
        }
        os.writeln(fnSb.toString())
        os.writeln()
    }

    // Gen function wrappers
    for ((i, fn) in withIndex(funcs)) {
        let fnSb = StringBuilder()
        var hasVaList = false
        fnSb.append("public func ${CAPI_IMPL_SYMBOL_PREFIX}${fn.name}(")
        let params = ArrayList<FuncParameter>.fromIterator(
            fn.params |> filter {
            item => !(item.name == "..." && item.ty == "...")
        })
        for ((i, p) in withIndex(params)) {
            if (p.ty == "va_list") {
                hasVaList = true
            }
            fnSb.append("${getValidCjIdentifier(p.name)}: ${CjType.fromCType(p.ty, cArrayAsPointer: true)}")
            if (i != params.size - 1) {
                fnSb.append(", ")
            }
        }
        fnSb.append("): ${CjType.fromCType(fn.retType, cArrayAsPointer: true)} {\n")
        fnSb.append("    return unsafe { ${fn.name}(")
        for ((i, p) in withIndex(params)) {
            fnSb.append(getValidCjIdentifier(p.name))
            if (i != params.size - 1) {
                fnSb.append(", ")
            }
        }
        fnSb.append(") }\n")
        fnSb.append("}")
        if (hasVaList) {
            os.writeln("// Cangjie does not support `va_list`")
            os.writeln("// ${fnSb.toString().split("\n")[0]} ...")
        } else {
            os.writeln(fnSb.toString())
            symbols.append("${CAPI_IMPL_SYMBOL_PREFIX}${fn.name}")
        }
        if (i != funcs.size - 1) {
            os.writeln()
        }
    }

    return symbols
}

func genFuncsCode(filename: String, pkgName: String, funcs: ArrayList<FuncSignature>): ArrayList<String> {
    try (fp = File(filename, OpenOption.CreateOrTruncate(false))) {
        try (sw = StringWriter(fp)) {
            return genFuncsCode(sw, pkgName, funcs)
        }
    }
    throw IllegalStateException("illegal state")
}

func genFuncsWCAPICode<T>(
    os: StringWriter<T>,
    pkgName: String,
    capiPkgName: String,
    macrosPkgName: String,
    funcs: ArrayList<FuncSignature>,
    typeAlias: HashMap<String, CjType>,
    definedStructNames: HashSet<String>,
    apiInfo: APIInfo
) where T <: OutputStream {
    // SOME COMMENTS ....
    //
    // package xxx
    //
    // import capiPkgName
    //
    // public func funcName0(param0: Param0, param1: Param1 ...): RetType {
    //    capiPkgName.funcName0(param0.xxx(), param1.xxx())
    // }
    // 
    // ...

    os.writeln(AUTOGENERATED_FILE_HEAD_COMMENTS)
    os.writeln()
    os.writeln("package ${pkgName}")
    os.writeln()
    os.writeln("import ${capiPkgName}")
    os.writeln("import ${macrosPkgName}.*")
    os.writeln("import std.math.* // for MathExtension")
    os.writeln()
    for (fn in funcs) {
        if (fn.isDestructor) {
            continue // Skip destructors
        }

        let fnSb = StringBuilder()
        var hasVaList = false
        let params = ArrayList<FuncParameter>.fromIterator(
            fn.params |> filter {
            item => !(item.name == "..." && item.ty == "...")
        })
        if (fn.structName == "") { // global function
            fnSb.append("public func ${fn.originalName}(") // public using original names
        } else if (definedStructNames.contains(fn.structName)) {
            fnSb.append("func ${fn.name}(") // internal using capi names
        } else {
            continue // Skip undefined structs' function
        }
        let callArgs = ArrayList<String>()
        for ((i, p) in withIndex(params)) {
            if (p.ty == "va_list") {
                hasVaList = true
            }
            let ty = CjType.fromCType(p.ty, cArrayAsPointer: true)
            let (wcapiTy, wcapiArg) = getWCAPIArgument(ty, p.name, typeAlias)
            fnSb.append("${getValidCjIdentifier(p.name)}: ${wcapiTy}")
            callArgs.append(wcapiArg)
            if (!hasVaList && fn.structName == "") {
                apiInfo.updateArgMappingForGlobalFunction(p.ty, wcapiTy)
            }
            if (i != params.size - 1) {
                fnSb.append(", ")
            }
        }
        fnSb.append(")")

        if (hasVaList && fn.structName == "") {
            apiInfo.addUncoveredGlobalFunction(fn.imguiFuncDecl)
        }

        if (hasVaList) {
            os.writeln("// Cangjie does not support `va_list`")
            os.writeln("// ${fnSb.toString()} ...")
        } else {
            let capiCall = StringBuilder()
            capiCall.append("${getPkgName(capiPkgName)}.${fn.name}(")
            for ((i, arg) in withIndex(callArgs)) {
                capiCall.append(arg)
                if (i != callArgs.size - 1) {
                    capiCall.append(", ")
                }
            }
            capiCall.append(")")

            let retTy = CjType.fromCType(fn.retType, cArrayAsPointer: true)
            let (wcapiRetTy, wcapiRet) = getWCAPIReturn(retTy, capiCall.toString(), typeAlias)

            if (fn.structName == "") {
                let cjSig = "${fnSb.toString()}: ${wcapiRetTy}"
                apiInfo.updateRetMappingForGlobalFunction(fn.retType, wcapiRetTy)
                apiInfo.addDescForGlobalFunction(
                    cjSig,
                    FunctionDesc(
                        originalFunctionDecl: fn.imguiFuncDecl,
                        cimguiFunctionDecl: fn.cimguiFuncDecl,
                    )
                )
            }


            if (!fn.defaultaArgs.isEmpty()) {
                let defaultArgs = ArrayList<String>()
                for (p in params) {
                    if (let Some(arg) <- fn.defaultaArgs.get(p.name)) {
                        defaultArgs.append(transLiteralFromCToWCAPI(arg, p.ty, typeAlias))
                    }
                }

                os.write("@DefaultArgs[")
                for ((i, arg) in withIndex(defaultArgs)) {
                    os.write(arg)
                    if (i != defaultArgs.size - 1) {
                        os.write(", ")
                    }
                }
                os.writeln("]")
            }

            os.writeln("${fnSb.toString()}: ${wcapiRetTy} {")
            os.writeln("    return ${wcapiRet}")
            os.writeln("}")
        }
        os.writeln()
    }
}

func genFuncsWCAPICode(
    filename: String,
    pkgName: String,
    capiPkgName: String,
    macrosPkgName: String,
    funcs: ArrayList<FuncSignature>,
    typeAlias: HashMap<String, CjType>,
    definedStructNames: HashSet<String>,
    apiInfo: APIInfo
) {
    try (fp = File(filename, OpenOption.CreateOrTruncate(false))) {
        try (sw = StringWriter(fp)) {
            genFuncsWCAPICode(sw, pkgName, capiPkgName, macrosPkgName, funcs, typeAlias, definedStructNames, apiInfo)
        }
    }
}
