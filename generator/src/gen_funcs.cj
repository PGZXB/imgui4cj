package cimgui_generator

from std import collection.{map, filter}

struct FuncParameter {
    FuncParameter(let name: String, let ty: String) {
    }
}

struct FuncSignature {
    FuncSignature(let name: String, let params: ArrayList<FuncParameter>, let retType: String, let structName: ?String,
        let isConstructor: Bool, let isDestructor: Bool) {
    }
}

func parseFuncsJson(funcsJson: JsonValue): ArrayList<FuncSignature> {
    let result = ArrayList<FuncSignature>()

    for ((_, fnOverloads) in funcsJson.asObject().getFields()) {
        for (fnSig in fnOverloads.asArray().getItems() |> map {
                item => item.asObject()
            } |> filter {
                item => !(item.get("templated")?.asBool().getValue() ?? false)
            }) {
            if (fnSig.get("constructor")?.asBool().getValue() ?? false) {
                // ret type is `StructType*`
                fnSig.put("ret", JsonString(fnSig["stname"].asString().getValue() + "*"))
            }
            result.append(
                FuncSignature(
                    fnSig["ov_cimguiname"].asString().getValue(), // name
                    ArrayList<FuncParameter>.fromIterator( // params
                        fnSig["argsT"].asArray().getItems() |> map(
                        {
                            item =>
                            let obj = item.asObject()
                            // NOTE: Only for cimgui: avoid using more powerful/complex library
                            var ty = obj["type"].asString().getValue()
                            if (ty == "int(*)(void const*,void const*)") {
                                ty = "int(*)(void const* arg1,void const* arg2)"
                            } else if (ty == "const char*(*)(void*,int)") {
                                ty = "const char*(*)(void* arg1,int arg2)"
                            }
                            return FuncParameter(obj["name"].asString().getValue(), ty)
                        }
                    )),
                    fnSig["ret"].asString().getValue(), // retType
                    fnSig.get("stname")?.asString().getValue() ?? "", // structName
                    fnSig.get("constructor")?.asBool().getValue() ?? false, // isConstructor
                    fnSig.get("destructor")?.asBool().getValue() ?? false // isDestructor
                )
            )
        }
    }

    return result
}

func genFuncsCode<T>(os: StringWriter<T>, pkgName: String, funcs: ArrayList<FuncSignature>) where T <: OutputStream {
    // SOME COMMENTS ....
    //
    // package xxx
    //
    // @C
    // foreign func funcName0(param0: Param0, param1: Param1 ...): RetType
    // 
    // @C
    // ...
    //
    // public func _capi_funcName0(param0: Param0, param1: Param1 ...): RetType {
    //     return unsafe { funcName0(param0, param1 ...) }
    // }

    let symbols = ArrayList<String>()
    os.writeln(AUTOGENERATED_FILE_HEAD_COMMENTS)
    os.writeln()
    os.writeln("package ${pkgName}")
    os.writeln()

    // Gen foreign func decls
    for ((i, fn) in withIndex(funcs)) {
        let fnSb = StringBuilder()
        var hasVaList = false
        fnSb.append("foreign func ${fn.name}(")
        for ((i, p) in withIndex(fn.params)) {
            if (p.ty == "va_list") {
                hasVaList = true
            }
            if (p.name == "..." && p.ty == "...") {
                fnSb.append("...")
            } else {
                fnSb.append("${getValidCjIdentifier(p.name)}: ${CjType.fromCType(p.ty, cArrayAsPointer: true)}")
            }
            if (i != fn.params.size - 1) {
                fnSb.append(", ")
            }
        }
        fnSb.append("): ${CjType.fromCType(fn.retType, cArrayAsPointer: true)}")
        if (hasVaList) {
            os.writeln("// Cangjie does not support `va_list`")
            os.write("// ")
        }
        os.writeln(fnSb.toString())
        os.writeln()
    }

    // Gen function wrappers
    for ((i, fn) in withIndex(funcs)) {
        let fnSb = StringBuilder()
        var hasVaList = false
        fnSb.append("public func ${CAPI_IMPL_SYMBOL_PREFIX}${fn.name}(")
        let params = ArrayList<FuncParameter>.fromIterator(
            fn.params |> filter {
            item => !(item.name == "..." && item.ty == "...")
        })
        for ((i, p) in withIndex(params)) {
            if (p.ty == "va_list") {
                hasVaList = true
            }
            fnSb.append("${getValidCjIdentifier(p.name)}: ${CjType.fromCType(p.ty, cArrayAsPointer: true)}")
            if (i != params.size - 1) {
                fnSb.append(", ")
            }
        }
        fnSb.append("): ${CjType.fromCType(fn.retType, cArrayAsPointer: true)} {\n")
        fnSb.append("    return unsafe { ${fn.name}(")
        for ((i, p) in withIndex(params)) {
            fnSb.append(getValidCjIdentifier(p.name))
            if (i != params.size - 1) {
                fnSb.append(", ")
            }
        }
        fnSb.append(") }\n")
        fnSb.append("}")
        if (hasVaList) {
            os.writeln("// Cangjie does not support `va_list`")
            os.writeln("// ${fnSb.toString().split("\n")[0]} ...")
        } else {
            os.writeln(fnSb.toString())
            symbols.append("${CAPI_IMPL_SYMBOL_PREFIX}${fn.name}")
        }
        if (i != funcs.size - 1) {
            os.writeln()
        }
    }

    return symbols
}

func genFuncsCode(filename: String, pkgName: String, funcs: ArrayList<FuncSignature>): ArrayList<String> {
    try (fp = File(filename, OpenOption.CreateOrTruncate(false))) {
        try (sw = StringWriter(fp)) {
            return genFuncsCode(sw, pkgName, funcs)
        }
    }
    throw IllegalStateException("illegal state")
}

func genFuncsWCAPICode<T>(os: StringWriter<T>, pkgName: String, capiPkgName: String, funcs: ArrayList<FuncSignature>,
    typeAlias: HashMap<String, CjType>) where T <: OutputStream {
    // SOME COMMENTS ....
    //
    // package xxx
    //
    // import capiPkgName.*
    //
    // public func funcName0(param0: Param0, param1: Param1 ...): RetType {
    //    capiPkgName.funcName0(param0.xxx(), param1.xxx())
    // }
    // 
    // ...

    os.writeln(AUTOGENERATED_FILE_HEAD_COMMENTS)
    os.writeln()
    os.writeln("package ${pkgName}")
    os.writeln()
    os.writeln("import ${capiPkgName}.*")
    os.writeln()
    for (fn in funcs) {
        let fnSb = StringBuilder()
        var hasVaList = false
        let params = ArrayList<FuncParameter>.fromIterator(
            fn.params |> filter {
            item => !(item.name == "..." && item.ty == "...")
        })
        if (fn.structName == "") { // global function
            fnSb.append("public func ${fn.name[2..]}(")
        } else {
            fnSb.append("func ${fn.name}(")
        }
        let callArgs = ArrayList<String>()
        for ((i, p) in withIndex(params)) {
            if (p.ty == "va_list") {
                hasVaList = true
            }
            let ty = CjType.fromCType(p.ty, cArrayAsPointer: true)
            let (wcapiTy, wcapiArg) = getWCAPIArgument(ty, p.name, typeAlias)
            fnSb.append("${getValidCjIdentifier(p.name)}: ${wcapiTy}")
            callArgs.append(wcapiArg)
            if (i != params.size - 1) {
                fnSb.append(", ")
            }
        }
        fnSb.append(")")

        if (hasVaList) {
            os.writeln("// Cangjie does not support `va_list`")
            os.writeln("// ${fnSb.toString()} ...")
        } else {
            let capiCall = StringBuilder()
            capiCall.append("${capiPkgName}.${fn.name}(")
            for ((i, arg) in withIndex(callArgs)) {
                capiCall.append(arg)
                if (i != callArgs.size - 1) {
                    capiCall.append(", ")
                }
            }
            capiCall.append(")")

            let retTy = CjType.fromCType(fn.retType, cArrayAsPointer: true)
            let (wcapiRetTy, wcapiRet) = getWCAPIReturn(retTy, capiCall.toString(), typeAlias)

            os.writeln("${fnSb.toString()}: ${wcapiRetTy} {")
            os.writeln("    return ${wcapiRet}")
            os.writeln("}")
        }
        os.writeln()
    }
}

func genFuncsWCAPICode(filename: String, pkgName: String, capiPkgName: String, funcs: ArrayList<FuncSignature>,
    typeAlias: HashMap<String, CjType>) {
    try (fp = File(filename, OpenOption.CreateOrTruncate(false))) {
        try (sw = StringWriter(fp)) {
            genFuncsWCAPICode(sw, pkgName, capiPkgName, funcs, typeAlias)
        }
    }
}
