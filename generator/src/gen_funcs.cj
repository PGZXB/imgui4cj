package cimgui_generator

from std import collection.{map, filter}

struct FuncParameter {
    FuncParameter(let name: String, let ty: String) {
    }
}

struct FuncSignature {
    FuncSignature(let name: String, let params: ArrayList<FuncParameter>, let retType: String) {
    }
}

func parseFuncsJson(funcsJson: JsonValue): ArrayList<FuncSignature> {
    let result = ArrayList<FuncSignature>()

    for ((_, fnOverloads) in funcsJson.asObject().getFields()) {
        for (fnSig in fnOverloads.asArray().getItems() |> map {
                item => item.asObject()
            } |> filter {
                item => !(item.get("templated")?.asBool().getValue() ?? false)
            }) {
            if (fnSig.get("constructor")?.asBool().getValue() ?? false) {
                // ret type is `StructType*`
                fnSig.put("ret", JsonString(fnSig["stname"].asString().getValue() + "*"))
            }
            result.append(
                FuncSignature(
                    fnSig["ov_cimguiname"].asString().getValue(), // name
                    ArrayList<FuncParameter>.fromIterator( // params
                        fnSig["argsT"].asArray().getItems() |> map(
                        {
                            item =>
                            let obj = item.asObject()
                            // NOTE: Only for cimgui: avoid using more powerful/complex library
                            var ty = obj["type"].asString().getValue()
                            if (ty == "int(*)(void const*,void const*)") {
                                ty = "int(*)(void const* arg1,void const* arg2)"
                            } else if (ty == "const char*(*)(void*,int)") {
                                ty = "const char*(*)(void* arg1,int arg2)"
                            }
                            return FuncParameter(obj["name"].asString().getValue(), ty)
                        }
                    )),
                    fnSig["ret"].asString().getValue() // retType
                )
            )
        }
    }

    return result
}

func genFuncsCode<T>(os: StringWriter<T>, pkgName: String, funcs: ArrayList<FuncSignature>) where T <: OutputStream {
    // SOME COMMENTS ....
    //
    // package xxx
    //
    // @C
    // foreign func funcName0(param0: Param0, param1: Param1 ...): RetType
    // 
    // @C
    // ...

    os.writeln(AUTOGENERATED_FILE_HEAD_COMMENTS)
    os.writeln()
    os.writeln("package ${pkgName}")
    os.writeln()
    for ((i, fn) in withIndex(funcs)) {
        let fnSb = StringBuilder()
        var hasVaList = false
        fnSb.append("foreign func ${fn.name}(")
        for ((i, p) in withIndex(fn.params)) {
            if (p.ty == "va_list") {
                hasVaList = true
            }
            if (p.name == "..." && p.ty == "...") {
                fnSb.append("...")
            } else {
                fnSb.append("${getValidCjIdentifier(p.name)}: ${CjType.fromCType(p.ty)}")
            }
            if (i != fn.params.size - 1) {
                fnSb.append(", ")
            }
        }
        fnSb.append("): ${CjType.fromCType(fn.retType)}")
        if (hasVaList) {
            os.writeln("// Cangjie does not support `va_list`")
            os.write("// ")
        }
        os.writeln(fnSb.toString())
        if (i != funcs.size - 1) {
            os.writeln()
        }
    }
}

func genFuncsCode(filename: String, pkgName: String, funcs: ArrayList<FuncSignature>) {
    try (fp = File(filename, OpenOption.CreateOrTruncate(false))) {
        try (sw = StringWriter(fp)) {
            return genFuncsCode(sw, pkgName, funcs)
        }
    }
}
